"""
Solo Leveling Backend API - Data Structures & Algorithms Learning Platform
Main application file with REST API endpoints for DSA learning content.
Chapters are dynamically generated by OpenAI for better flexibility.
"""

from flask import Flask, jsonify, request
from flask_cors import CORS
import openai
import json
import os
import time
import random
import re
from typing import List, Dict, Any, Optional
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Initialize Flask application
app = Flask(__name__)
CORS(app)  # Enable Cross-Origin Resource Sharing


# ============================================================================
# CONFIGURATION CLASSES
# ============================================================================

class Config:
    """
    Central configuration class for the application.
    Stores all configuration constants and environment variables.
    """

    # OpenAI Configuration
    OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
    OPENAI_MODEL = os.getenv('OPENAI_MODEL', 'gpt-3.5-turbo')

    # Supported Programming Languages
    SUPPORTED_LANGUAGES = ['python', 'java', 'javascript', 'cpp', 'csharp', 'go', 'rust', 'swift', 'kotlin']

    # Application Settings
    DEFAULT_LANGUAGE = 'python'
    MAX_QUESTION_LEVEL = 10
    MIN_QUESTION_LEVEL = 1

    # Default chapters (used as fallback)
    DEFAULT_CHAPTERS = [
        {"id": 1, "name": "Arrays & Strings", "topics": ["arrays", "strings", "manipulation", "searching"], "difficulty_levels": 10},
        {"id": 2, "name": "Linked Lists", "topics": ["singly linked", "doubly linked", "cycle detection"], "difficulty_levels": 10},
        {"id": 3, "name": "Stacks & Queues", "topics": ["stack operations", "queue implementations", "applications"], "difficulty_levels": 10},
        {"id": 4, "name": "Trees & BST", "topics": ["binary trees", "BST", "traversal algorithms"], "difficulty_levels": 10},
        {"id": 5, "name": "Graphs", "topics": ["graph representation", "traversal", "shortest path"], "difficulty_levels": 10},
        {"id": 6, "name": "Dynamic Programming", "topics": ["memoization", "tabulation", "problem patterns"], "difficulty_levels": 10},
        {"id": 7, "name": "Sorting Algorithms", "topics": ["comparison sorts", "non-comparison sorts", "optimization"], "difficulty_levels": 10},
        {"id": 8, "name": "Searching Algorithms", "topics": ["linear search", "binary search", "hash-based search"], "difficulty_levels": 10},
        {"id": 9, "name": "Recursion", "topics": ["base cases", "recursive patterns", "optimization"], "difficulty_levels": 10},
        {"id": 10, "name": "Bit Manipulation", "topics": ["bit operations", "bitmasks", "applications"], "difficulty_levels": 10}
    ]


# ============================================================================
# UTILITY CLASSES
# ============================================================================

class JSONParser:
    """
    Utility class for parsing and cleaning JSON responses from OpenAI.
    Handles various formatting issues that OpenAI might return.
    """

    @staticmethod
    def extract_json_from_text(text: str) -> str:
        """
        Extract JSON from text that might contain markdown or other formatting.

        Args:
            text: Raw text that might contain JSON

        Returns:
            str: Extracted JSON string
        """
        # Try to parse directly first
        try:
            json.loads(text)
            return text
        except json.JSONDecodeError:
            pass

        # Remove markdown code blocks
        text = re.sub(r'```json\s*', '', text)
        text = re.sub(r'```\s*', '', text)

        # Find JSON object boundaries
        start_idx = text.find('{')
        end_idx = text.rfind('}')

        if start_idx != -1 and end_idx != -1 and end_idx > start_idx:
            json_str = text[start_idx:end_idx + 1]

            # Try to parse the extracted JSON
            try:
                json.loads(json_str)
                return json_str
            except json.JSONDecodeError:
                pass

        # If still not valid, try to fix common issues
        text = JSONParser._fix_common_json_issues(text)

        return text.strip()

    @staticmethod
    def _fix_common_json_issues(text: str) -> str:
        """
        Fix common JSON formatting issues.

        Args:
            text: JSON string with potential issues

        Returns:
            str: Fixed JSON string
        """
        # Fix missing quotes around keys
        text = re.sub(r'(\w+):', r'"\1":', text)

        # Fix single quotes to double quotes
        text = text.replace("'", '"')

        # Fix trailing commas
        text = re.sub(r',\s*}', '}', text)
        text = re.sub(r',\s*]', ']', text)

        # Fix unescaped quotes in strings
        text = re.sub(r'(?<!\\)"(?!\s*[:,\]\}])', r'\"', text)

        return text


# ============================================================================
# SERVICE CLASSES
# ============================================================================

class OpenAIService:
    """
    Service class for handling OpenAI API interactions.
    Manages API connections, content generation, and fallback mechanisms.
    """

    def __init__(self):
        """Initialize OpenAI service with API credentials."""
        self.api_key = Config.OPENAI_API_KEY
        self.model = Config.OPENAI_MODEL
        self.connected = False

        # Configure OpenAI API if key is available
        if self.api_key:
            try:
                openai.api_key = self.api_key
                # Test the connection with a simple call
                self.connected = self._test_connection()
                if self.connected:
                    print("‚úÖ OpenAI API configured successfully")
                else:
                    print("‚ö†Ô∏è OpenAI API key found but connection test failed")
            except Exception as e:
                print(f"‚ùå OpenAI configuration error: {e}")
                self.connected = False
        else:
            print("‚ö†Ô∏è OpenAI API key not found in environment variables")
            print("‚ö†Ô∏è Using enhanced fallback content generation")
            self.connected = False

    def _test_connection(self) -> bool:
        """
        Test the connection to OpenAI API with a small request.

        Returns:
            bool: True if connection is successful, False otherwise.
        """
        try:
            # Make a small test request to verify connectivity
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[{"role": "user", "content": "Say 'connected'"}],
                max_tokens=5
            )
            return True
        except openai.error.AuthenticationError:
            print("‚ùå OpenAI Authentication Error: Invalid API key")
            return False
        except openai.error.RateLimitError:
            print("‚ö†Ô∏è OpenAI Rate Limit Error: Too many requests")
            return True  # API is working, just rate limited
        except Exception as e:
            print(f"‚ùå OpenAI connection test failed: {e}")
            return False

    def check_connection(self) -> bool:
        """
        Check if OpenAI API is connected and available.

        Returns:
            bool: True if connected, False otherwise.
        """
        return self.connected

    def generate_chapters(self, language: str = "python") -> List[Dict[str, Any]]:
        """
        Generate dynamic DSA chapters based on language and current trends.

        Args:
            language: Programming language to tailor chapters for

        Returns:
            List[Dict]: List of chapter objects with id, name, and topics
        """
        # Use OpenAI if available, otherwise use default chapters
        if not self.connected:
            print(f"‚ö†Ô∏è OpenAI not available, using default chapters for {language}")
            return self._enhance_default_chapters(language)

        print(f"üöÄ Generating dynamic chapters for {language}...")

        prompt = self._build_chapters_prompt(language)

        try:
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": """You are an expert computer science curriculum designer specializing in Data Structures and Algorithms.
                        IMPORTANT: You must return ONLY valid JSON. Do not include any explanations, markdown formatting, or additional text outside the JSON.
                        """
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.7,
                max_tokens=1500
            )

            content = response.choices[0].message.content.strip()
            print(f"‚úÖ Received OpenAI response for chapters")

            # Try to parse the JSON response
            result = self._parse_openai_json_response(content, "chapters")
            if result and isinstance(result, list):
                # Validate and enhance the chapters
                validated_chapters = self._validate_and_enhance_chapters(result, language)
                print(f"‚úÖ Successfully generated {len(validated_chapters)} dynamic chapters for {language}")
                return validated_chapters
            else:
                print(f"‚ö†Ô∏è Could not parse chapters JSON, using enhanced default chapters")

        except openai.error.RateLimitError:
            print(f"‚ö†Ô∏è OpenAI rate limit reached for chapters, using enhanced default chapters")
        except openai.error.AuthenticationError:
            print(f"‚ùå OpenAI authentication failed, using enhanced default chapters")
            self.connected = False
        except Exception as e:
            print(f"‚ùå OpenAI API error for chapters: {e}")

        # If anything goes wrong, use enhanced default chapters
        return self._enhance_default_chapters(language)

    def _build_chapters_prompt(self, language: str) -> str:
        """
        Build prompt for dynamic chapter generation.

        Args:
            language: Programming language

        Returns:
            str: Formatted prompt for OpenAI
        """
        current_year = time.strftime("%Y")

        return f"""
        Create a comprehensive curriculum of Data Structures and Algorithms chapters for {language} programmers.
        
        Current Year: {current_year}
        Programming Language: {language}
        
        IMPORTANT: Return ONLY valid JSON. Do not include any explanations or additional text.
        
        Requirements:
        1. Create 8-12 chapters covering essential DSA topics
        2. Include both fundamental and advanced topics
        3. Tailor topics to {language}'s strengths and common patterns
        4. Consider current trends in software engineering interviews
        5. Include topics relevant to real-world applications
        
        For each chapter, include:
        - A unique ID (sequential starting from 1)
        - A descriptive name (e.g., "Arrays & Strings", "Dynamic Programming Patterns")
        - 3-5 specific topics covered in that chapter
        - difficulty_levels: 10 (always)
        
        Return as a JSON array of chapter objects:
        [
            {{
                "id": 1,
                "name": "Chapter Name",
                "topics": ["topic1", "topic2", "topic3"],
                "difficulty_levels": 10
            }},
            ...
        ]
        
        Make the curriculum modern, practical, and comprehensive for {language} developers.
        """

    def _validate_and_enhance_chapters(self, chapters: List[Dict], language: str) -> List[Dict]:
        """
        Validate chapter structure and add any missing fields.

        Args:
            chapters: List of chapter dictionaries
            language: Programming language

        Returns:
            List[Dict]: Validated and enhanced chapters
        """
        validated_chapters = []

        for i, chapter in enumerate(chapters, 1):
            # Ensure chapter has required fields
            if not isinstance(chapter, dict):
                continue

            # Set or validate ID
            chapter_id = chapter.get('id', i)

            # Ensure name exists
            name = chapter.get('name', f'DSA Chapter {chapter_id}')

            # Ensure topics exists and is a list
            topics = chapter.get('topics', [])
            if not isinstance(topics, list):
                topics = []

            # Add language-specific topics if needed
            if language == 'python' and 'list comprehensions' not in ' '.join(topics).lower():
                topics.append(f"{language} specific optimizations")
            elif language == 'java' and 'streams api' not in ' '.join(topics).lower():
                topics.append("Java Streams API")
            elif language == 'javascript' and 'async/await' not in ' '.join(topics).lower():
                topics.append("Async patterns in DSA")

            validated_chapter = {
                'id': chapter_id,
                'name': name,
                'topics': topics[:5],  # Limit to 5 topics max
                'difficulty_levels': 10
            }

            validated_chapters.append(validated_chapter)

        # Ensure we have at least some chapters
        if not validated_chapters:
            return self._enhance_default_chapters(language)

        return validated_chapters[:12]  # Limit to 12 chapters max

    def _enhance_default_chapters(self, language: str) -> List[Dict[str, Any]]:
        """
        Enhance default chapters with language-specific modifications.

        Args:
            language: Programming language

        Returns:
            List[Dict]: Enhanced default chapters
        """
        enhanced_chapters = []

        for chapter in Config.DEFAULT_CHAPTERS:
            # Create a copy of the chapter
            enhanced_chapter = chapter.copy()

            # Add language-specific topics
            base_topics = enhanced_chapter['topics']

            if language == 'python':
                enhanced_topics = base_topics + ["Pythonic implementations", "List comprehensions", "Generator expressions"]
            elif language == 'java':
                enhanced_topics = base_topics + ["Java Collections Framework", "Streams API", "Concurrent implementations"]
            elif language == 'javascript':
                enhanced_topics = base_topics + ["ES6+ features", "Async/await patterns", "Functional programming"]
            elif language == 'cpp':
                enhanced_topics = base_topics + ["STL implementations", "Memory management", "Template metaprogramming"]
            elif language == 'csharp':
                enhanced_topics = base_topics + [".NET collections", "LINQ expressions", "Async patterns"]
            elif language == 'go':
                enhanced_topics = base_topics + ["Go routines", "Channels", "Standard library"]
            elif language == 'rust':
                enhanced_topics = base_topics + ["Ownership patterns", "Lifetime management", "Safe concurrency"]
            else:
                enhanced_topics = base_topics + [f"{language} best practices"]

            enhanced_chapter['topics'] = enhanced_topics
            enhanced_chapters.append(enhanced_chapter)

        return enhanced_chapters

    def _parse_openai_json_response(self, content: str, response_type: str) -> Optional[Any]:
        """
        Parse OpenAI JSON response, handling various formatting issues.

        Args:
            content: Raw content from OpenAI
            response_type: Type of response ("chapters", "concept", or "question")

        Returns:
            Any: Parsed JSON or None if parsing fails
        """
        try:
            # Try direct parse first
            return json.loads(content)
        except json.JSONDecodeError:
            # Extract and clean JSON
            json_str = JSONParser.extract_json_from_text(content)
            try:
                return json.loads(json_str)
            except json.JSONDecodeError as e:
                print(f"‚ùå JSON decode error for {response_type}: {e}")
                if response_type != "chapters":  # Don't print full content for chapters (could be long)
                    print(f"üìù Raw content (first 500 chars): {content[:500]}")
                return None

    def generate_concept_content(self, chapter_name: str, topics: List[str],
                                language: str) -> Dict[str, Any]:
        """
        Generate concept explanation content for a DSA chapter.

        Args:
            chapter_name: Name of the DSA chapter (e.g., "Arrays & Strings")
            topics: List of topics to cover within the chapter
            language: Programming language for code examples

        Returns:
            Dict containing concept content with title, theory, examples, etc.
        """
        # Use OpenAI if available, otherwise use enhanced fallback
        if not self.connected:
            print(f"‚ö†Ô∏è OpenAI not available, using enhanced fallback concept for {chapter_name}")
            return self._create_enhanced_concept(chapter_name, topics, language)

        print(f"üöÄ Generating concept content for {chapter_name} in {language}...")

        # Build prompt for OpenAI
        prompt = self._build_concept_prompt(chapter_name, topics, language)

        try:
            # Call OpenAI API
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": """You are an expert computer science educator creating comprehensive learning materials for data structures and algorithms.
                        IMPORTANT: You must return ONLY valid JSON. Do not include any explanations, markdown formatting, or additional text outside the JSON.
                        """
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.7,
                max_tokens=2000
            )

            content = response.choices[0].message.content.strip()
            print(f"‚úÖ Received OpenAI response for {chapter_name}")

            # Try to parse the JSON response
            result = self._parse_openai_json_response(content, "concept")
            if result:
                # Validate the parsed content
                if self._validate_concept_content(result):
                    print(f"‚úÖ Successfully generated concept for {chapter_name}")
                    return result
                else:
                    print(f"‚ö†Ô∏è Invalid concept structure for {chapter_name}, using fallback")
            else:
                print(f"‚ö†Ô∏è Could not parse JSON for {chapter_name}, using fallback")

        except openai.error.RateLimitError:
            print(f"‚ö†Ô∏è OpenAI rate limit reached for {chapter_name}, using fallback")
        except openai.error.AuthenticationError:
            print(f"‚ùå OpenAI authentication failed, using fallback")
            self.connected = False
        except Exception as e:
            print(f"‚ùå OpenAI API error for concept: {e}")

        # If anything goes wrong, use fallback
        return self._create_enhanced_concept(chapter_name, topics, language)

    def _build_concept_prompt(self, chapter_name: str, topics: List[str],
                             language: str) -> str:
        """
        Build the prompt for concept content generation.

        Args:
            chapter_name: Name of the chapter
            topics: List of topics
            language: Programming language

        Returns:
            str: Formatted prompt for OpenAI
        """
        return f"""
        Create comprehensive learning concept content for "{chapter_name}" in {language}.
        
        Topics to cover: {', '.join(topics)}
        
        IMPORTANT: Return ONLY valid JSON. Do not include any explanations or additional text.
        
        Provide detailed theory explanation covering:
        - Fundamental concepts and definitions
        - Key operations and their implementations
        - Time and space complexity analysis
        - Real-world applications and use cases
        - {language}-specific best practices, patterns, and examples
        
        Return as JSON with these exact fields:
        {{
            "title": "comprehensive title for {chapter_name} in {language}",
            "overview": "brief overview description of {chapter_name}",
            "theory_content": "detailed HTML-formatted content explaining {chapter_name} concepts with examples, code snippets, and diagrams where appropriate",
            "learning_objectives": ["objective1 related to {chapter_name}", "objective2", "objective3", "objective4"],
            "code_examples": [
                {{
                    "code": "simple but practical code example in {language} demonstrating {chapter_name} basics",
                    "explanation": "clear explanation of what the code does and why it's important"
                }}
            ],
            "key_takeaways": ["key takeaway 1", "key takeaway 2", "key takeaway 3"],
            "prerequisites": ["basic programming knowledge", "understanding of fundamental data types"],
            "estimated_study_time": "2-3 hours"
        }}
        
        Make the content engaging, educational, and practical for {language} learners.
        Include {language}-specific code examples that demonstrate key concepts in an idiomatic way.
        """

    def _validate_concept_content(self, concept: Dict) -> bool:
        """
        Validate the structure of concept content.

        Args:
            concept: Dictionary containing concept content

        Returns:
            bool: True if structure is valid, False otherwise
        """
        try:
            required_fields = [
                'title', 'overview', 'theory_content', 'learning_objectives',
                'code_examples', 'key_takeaways'
            ]

            # Check if all required fields are present
            for field in required_fields:
                if field not in concept:
                    print(f"‚ö†Ô∏è Missing required field: {field}")
                    return False

            # Check field types
            if not isinstance(concept['learning_objectives'], list):
                return False
            if not isinstance(concept['code_examples'], list):
                return False
            if not isinstance(concept['key_takeaways'], list):
                return False

            return True
        except Exception as e:
            print(f"‚ö†Ô∏è Validation error: {e}")
            return False

    def _create_enhanced_concept(self, chapter_name: str, topics: List[str],
                                language: str) -> Dict[str, Any]:
        """
        Create enhanced fallback concept content when OpenAI is unavailable.

        Args:
            chapter_name: Name of the chapter
            topics: List of topics
            language: Programming language

        Returns:
            Dict: Fallback concept content
        """
        # Pre-defined templates for common DSA chapters
        concept_templates = {
            "Arrays & Strings": {
                "title": f"Mastering Arrays & Strings in {language}",
                "overview": f"Learn fundamental array and string manipulation techniques in {language} with practical examples and real-world applications.",
                "theory_content": f"""
                <h2>Arrays & Strings Fundamentals in {language}</h2>
                <p>Arrays and strings are fundamental data structures that form the building blocks of most algorithms and applications.</p>
                
                <h3>üìö Core Concepts</h3>
                <ul>
                    <li><strong>Arrays:</strong> Contiguous memory locations storing elements of the same type</li>
                    <li><strong>Strings:</strong> Sequences of characters with various manipulation methods</li>
                    <li><strong>Indexing:</strong> Zero-based access to elements</li>
                    <li><strong>Mutability:</strong> Understanding which operations modify the original data</li>
                </ul>
                
                <h3>‚ö° Key Operations</h3>
                <ul>
                    <li><strong>Access:</strong> O(1) time complexity for random access</li>
                    <li><strong>Search:</strong> O(n) for linear search, better with binary search on sorted arrays</li>
                    <li><strong>Insertion/Deletion:</strong> O(n) for arrays, varies for other structures</li>
                    <li><strong>Sorting:</strong> Various algorithms with different time complexities</li>
                </ul>
                
                <h3>üîß {language} Specific Features</h3>
                <p>{language} provides built-in methods for efficient array and string manipulation:</p>
                <ul>
                    <li>List comprehensions and slicing</li>
                    <li>String methods for searching and manipulation</li>
                    <li>Memory-efficient data structures</li>
                </ul>
                
                <h3>üåç Real-world Applications</h3>
                <ul>
                    <li>Text processing and analysis</li>
                    <li>Data storage and retrieval systems</li>
                    <li>Algorithm implementations</li>
                    <li>Problem-solving in technical interviews</li>
                </ul>
                """
            },
            "Linked Lists": {
                "title": f"Linked Lists Mastery in {language}",
                "overview": f"Understand linked list data structures, their implementations, and applications in {language} with progressive difficulty levels.",
                "theory_content": f"""
                <h2>Linked Lists in {language}</h2>
                <p>Linked lists are dynamic data structures where elements are stored in nodes, each containing data and a reference to the next node.</p>
                
                <h3>üìö Types of Linked Lists</h3>
                <ul>
                    <li><strong>Singly Linked Lists:</strong> Each node points to the next node only</li>
                    <li><strong>Doubly Linked Lists:</strong> Nodes point to both next and previous nodes</li>
                    <li><strong>Circular Linked Lists:</strong> Last node points back to the first node</li>
                </ul>
                
                <h3>‚ö° Key Operations & Complexities</h3>
                <ul>
                    <li><strong>Access:</strong> O(n) - must traverse from head</li>
                    <li><strong>Search:</strong> O(n) - linear search required</li>
                    <li><strong>Insertion:</strong> O(1) at head, O(n) at tail</li>
                    <li><strong>Deletion:</strong> O(1) at head, O(n) at tail</li>
                </ul>
                
                <h3>üîß {language} Implementation</h3>
                <p>In {language}, linked lists are typically implemented using classes:</p>
                <ul>
                    <li>Node class with data and next pointer</li>
                    <li>LinkedList class managing head and operations</li>
                    <li>Memory-efficient dynamic allocation</li>
                </ul>
                """
            },
            "Stacks & Queues": {
                "title": f"Stacks & Queues in {language}",
                "overview": f"Master stack (LIFO) and queue (FIFO) data structures with practical implementations in {language}.",
                "theory_content": f"""
                <h2>Stacks & Queues in {language}</h2>
                <p>Stacks and queues are fundamental linear data structures with specific insertion and removal patterns.</p>
                
                <h3>üìö Stack (LIFO - Last In, First Out)</h3>
                <ul>
                    <li><strong>Operations:</strong> Push (add), Pop (remove), Peek (view top)</li>
                    <li><strong>Implementation:</strong> Arrays or linked lists</li>
                    <li><strong>Complexity:</strong> O(1) for all operations</li>
                </ul>
                
                <h3>üìö Queue (FIFO - First In, First Out)</h3>
                <ul>
                    <li><strong>Operations:</strong> Enqueue (add), Dequeue (remove), Peek (view front)</li>
                    <li><strong>Types:</strong> Simple, circular, priority, double-ended</li>
                    <li><strong>Complexity:</strong> O(1) for all operations with proper implementation</li>
                </ul>
                
                <h3>üîß {language} Implementations</h3>
                <p>{language} provides various ways to implement stacks and queues:</p>
                <ul>
                    <li>Using lists with append/pop operations</li>
                    <li>Collections.deque for efficient double-ended operations</li>
                    <li>Custom classes for specific requirements</li>
                </ul>
                """
            }
        }

        # Get template for the chapter or use generic template
        template = concept_templates.get(chapter_name, {
            "title": f"{chapter_name} in {language}",
            "overview": f"Comprehensive guide to {chapter_name} concepts and implementations in {language}. Progress through 10 difficulty levels from basic to advanced problems.",
            "theory_content": f"""
                <h2>{chapter_name} Concepts</h2>
                <p>Master {chapter_name.lower()} through progressive learning with 10 difficulty levels.</p>
                
                <h3>üìö Fundamental Concepts</h3>
                <ul>
                    <li>Core data structure principles</li>
                    <li>Key operations and their complexities</li>
                    <li>{language}-specific implementations</li>
                    <li>Best practices and patterns</li>
                </ul>
                
                <h3>üéØ Learning Progression</h3>
                <p>Start with basic operations (Level 1-3), move to algorithms (Level 4-6), 
                tackle optimization (Level 7-8), and master advanced scenarios (Level 9-10).</p>
                
                <h3>üîß {language} Features</h3>
                <p>Learn {language}-specific techniques and built-in methods for efficient {chapter_name.lower()} manipulation.</p>
                
                <h3>üåç Real-world Applications</h3>
                <p>Apply your knowledge to practical problems and technical interview scenarios.</p>
                """
        })

        # Get appropriate code example
        code_example = self._get_concept_example_code(language, chapter_name)

        # Build the complete concept response
        return {
            "title": template["title"],
            "overview": template["overview"],
            "theory_content": template["theory_content"],
            "learning_objectives": [
                f"Understand {chapter_name} fundamental concepts and operations",
                f"Implement {chapter_name} solutions in {language}",
                "Analyze time and space complexity of algorithms",
                "Solve problems of increasing difficulty (Level 1-10)",
                "Apply knowledge to real-world scenarios and interviews"
            ],
            "code_examples": [
                {
                    "code": code_example,
                    "explanation": f"Basic {chapter_name} implementation example in {language}"
                }
            ],
            "key_takeaways": [
                "Master core data structure concepts",
                "Develop systematic problem-solving approach",
                "Understand algorithm efficiency and optimization",
                "Build confidence through progressive difficulty levels",
                "Prepare for technical interviews and real-world applications"
            ],
            "prerequisites": ["Basic programming knowledge", f"Familiarity with {language} syntax"],
            "estimated_study_time": "2-4 hours"
        }

    def _get_concept_example_code(self, language: str, chapter_name: str) -> str:
        """
        Get example code for a concept based on language and chapter.

        Args:
            language: Programming language
            chapter_name: Name of the chapter

        Returns:
            str: Example code snippet
        """
        # Pre-defined code examples for different languages and chapters
        examples = {
            "python": {
                "Arrays & Strings": '''# Array creation and basic operations
arr = [1, 2, 3, 4, 5]
print("Array:", arr)
print("Length:", len(arr))
print("First element:", arr[0])
print("Last element:", arr[-1])

# String operations
s = "Hello, World!"
print("String:", s)
print("Uppercase:", s.upper())
print("Reversed:", s[::-1])
print("Contains 'World':", "World" in s)''',

                "Linked Lists": '''class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node
    
    def display(self):
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("None")

# Usage
ll = LinkedList()
ll.append(1)
ll.append(2)
ll.append(3)
ll.display()''',

                "Stacks & Queues": '''# Stack implementation using list
stack = []
stack.append(1)  # push
stack.append(2)
stack.append(3)
print("Stack:", stack)
popped = stack.pop()  # pop
print("Popped:", popped)
print("Stack after pop:", stack)

# Queue implementation
from collections import deque
queue = deque()
queue.append(1)  # enqueue
queue.append(2)
queue.append(3)
print("Queue:", list(queue))
dequeued = queue.popleft()  # dequeue
print("Dequeued:", dequeued)
print("Queue after dequeue:", list(queue))'''
            }
        }

        # Get language-specific examples or default to Python
        lang_examples = examples.get(language, examples["python"])
        return lang_examples.get(chapter_name,
                                 f"# {chapter_name} implementation in {language}\n# Code examples for {chapter_name} would be shown here")

    def generate_single_question(self, chapter_name: str, topics: List[str],
                                language: str, level: int) -> Dict[str, Any]:
        """
        Generate a single coding question for a specific difficulty level.

        Args:
            chapter_name: Name of the chapter
            topics: List of topics
            language: Programming language
            level: Difficulty level (1-10)

        Returns:
            Dict: Complete question with description, examples, hints, and solution
        """
        # Use OpenAI if available, otherwise use fallback
        if not self.connected:
            print(f"‚ö†Ô∏è OpenAI not available, using enhanced fallback for level {level}")
            return self._create_enhanced_question(chapter_name, topics, language, level)

        print(f"üöÄ Generating question for {chapter_name} - Level {level} in {language}...")

        # Build prompt for OpenAI
        prompt = self._build_single_question_prompt(chapter_name, topics, language, level)

        try:
            # Call OpenAI API
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": """You are an expert computer science educator creating coding problems for data structures and algorithms.
                        IMPORTANT: You must return ONLY valid JSON. Do not include any explanations, markdown formatting, or additional text outside the JSON.
                        """
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.7,
                max_tokens=1500
            )

            content = response.choices[0].message.content.strip()
            print(f"‚úÖ Received OpenAI response for level {level}")

            # Try to parse the JSON response
            result = self._parse_openai_json_response(content, "question")
            if result:
                # Validate the parsed content
                if self._validate_question(result, level):
                    print(f"‚úÖ Successfully generated question for level {level}")
                    return result
                else:
                    print(f"‚ö†Ô∏è Invalid question structure for level {level}, using fallback")
            else:
                print(f"‚ö†Ô∏è Could not parse JSON for level {level}, using fallback")

        except openai.error.RateLimitError:
            print(f"‚ö†Ô∏è OpenAI rate limit reached for level {level}, using fallback")
        except openai.error.AuthenticationError:
            print(f"‚ùå OpenAI authentication failed, using fallback")
            self.connected = False
        except Exception as e:
            print(f"‚ùå OpenAI API error for level {level}: {e}")

        # If anything goes wrong, use fallback
        return self._create_enhanced_question(chapter_name, topics, language, level)

    def _build_single_question_prompt(self, chapter_name: str, topics: List[str],
                                     language: str, level: int) -> str:
        """
        Build prompt for question generation.

        Args:
            chapter_name: Name of the chapter
            topics: List of topics
            language: Programming language
            level: Difficulty level

        Returns:
            str: Formatted prompt for OpenAI
        """
        # Difficulty descriptions for different levels
        difficulty_descriptions = {
            1: "very basic beginner level focusing on fundamental syntax and simple operations",
            2: "basic beginner level with simple multi-step problems",
            3: "easy level requiring basic algorithmic thinking",
            4: "easy-intermediate level with multiple conditions",
            5: "intermediate level with common algorithms",
            6: "intermediate-advanced level requiring optimization",
            7: "advanced level with complex data structures",
            8: "very advanced level with multiple constraints",
            9: "expert level with complex real-world scenarios",
            10: "master level requiring optimal solutions"
        }

        difficulty = difficulty_descriptions.get(level, "appropriate difficulty")

        return f"""
        Create a SINGLE coding problem about "{chapter_name}" for {language} programmers.
        
        Difficulty Level: {level}/10 - {difficulty}
        Programming Language: {language}
        Topics: {', '.join(topics)}
        
        IMPORTANT: Return ONLY valid JSON. Do not include any explanations or additional text.
        
        Requirements for level {level}:
        - Make it appropriate for level {level} difficulty
        - Focus on {self._get_level_focus(level)}
        - Include clear problem statement
        - Provide 2-3 examples with explanations
        - Include 3 helpful hints
        - Provide 3-5 test cases with input and expected output
        - Include a complete solution with explanation
        - Specify time and space complexity
        
        Return as JSON with these exact fields:
        {{
            "level": {level},
            "problem_id": "unique_problem_id_string",
            "title": "descriptive title about {chapter_name}",
            "description": "detailed problem statement explaining what needs to be solved",
            "examples": [
                {{"input": "example input 1", "output": "example output 1", "explanation": "explanation of example 1"}},
                {{"input": "example input 2", "output": "example output 2", "explanation": "explanation of example 2"}}
            ],
            "hints": ["hint 1 to help solve the problem", "hint 2", "hint 3"],
            "function_signature": "def solution(input_data): # for python or similar for other languages",
            "test_cases": [
                {{"input": "test input 1", "expected_output": "expected output 1"}},
                {{"input": "test input 2", "expected_output": "expected output 2"}},
                {{"input": "test input 3", "expected_output": "expected output 3"}}
            ],
            "solution": "complete solution code in {language}",
            "solution_explanation": "detailed explanation of how the solution works",
            "time_complexity": "O(n) or appropriate complexity",
            "space_complexity": "O(1) or appropriate complexity"
        }}
        
        Make sure the problem is distinct and focuses on {chapter_name} concepts.
        The problem should be appropriate for level {level} difficulty.
        """

    def _get_level_focus(self, level: int) -> str:
        """
        Get the learning focus for a specific difficulty level.

        Args:
            level: Difficulty level (1-10)

        Returns:
            str: Focus description for the level
        """
        focuses = {
            1: "basic syntax and single-step operations",
            2: "simple data structure operations",
            3: "basic loops and conditions",
            4: "multiple conditions and simple patterns",
            5: "common algorithms and moderate complexity",
            6: "optimization considerations",
            7: "advanced data structures",
            8: "complex constraints and edge cases",
            9: "real-world application scenarios",
            10: "optimal solutions and performance"
        }
        return focuses.get(level, "appropriate problem solving")

    def _validate_question(self, question: Dict, expected_level: int) -> bool:
        """
        Validate the structure of a question.

        Args:
            question: Dictionary containing question data
            expected_level: Expected difficulty level

        Returns:
            bool: True if structure is valid, False otherwise
        """
        try:
            required_fields = [
                'level', 'problem_id', 'title', 'description', 'examples',
                'hints', 'function_signature', 'test_cases', 'solution',
                'solution_explanation', 'time_complexity', 'space_complexity'
            ]

            # Check all required fields
            for field in required_fields:
                if field not in question:
                    print(f"‚ö†Ô∏è Missing required field: {field}")
                    return False

            # Verify level matches expected level
            if question.get('level') != expected_level:
                print(f"‚ö†Ô∏è Level mismatch: expected {expected_level}, got {question.get('level')}")
                return False

            # Check field types
            if not isinstance(question['examples'], list):
                return False
            if not isinstance(question['hints'], list):
                return False
            if not isinstance(question['test_cases'], list):
                return False

            return True
        except Exception as e:
            print(f"‚ö†Ô∏è Validation error: {e}")
            return False

    def _create_enhanced_question(self, chapter_name: str, topics: List[str],
                                 language: str, level: int) -> Dict[str, Any]:
        """
        Create enhanced fallback question when OpenAI is unavailable.

        Args:
            chapter_name: Name of the chapter
            topics: List of topics
            language: Programming language
            level: Difficulty level

        Returns:
            Dict: Fallback question data
        """
        # Different question templates for different difficulty ranges
        question_templates = [
            # Level 1-2: Basic operations
            {
                "template": "basic_operation",
                "title": f"Basic {self._get_operation_name(chapter_name, level)}",
                "description": f"Implement a basic {self._get_operation_name(chapter_name, level).lower()} operation for {chapter_name} in {language}.",
                "focus": "fundamental syntax and simple operations"
            },
            # Level 3-4: Simple algorithms
            {
                "template": "element_finding",
                "title": f"Find Element in {chapter_name}",
                "description": f"Find specific elements in {chapter_name} based on given conditions.",
                "focus": "basic algorithmic thinking and searching"
            },
            # Level 5-6: Data processing
            {
                "template": "data_processing",
                "title": f"Process {chapter_name} Data",
                "description": f"Process and transform {chapter_name} data according to specific rules.",
                "focus": "data transformation and processing"
            },
            # Level 7-8: Advanced operations
            {
                "template": "advanced_algorithm",
                "title": f"Advanced {chapter_name} Algorithm",
                "description": f"Implement an advanced algorithm for {chapter_name} manipulation.",
                "focus": "complex algorithms and optimization"
            },
            # Level 9-10: Complex problems
            {
                "template": "complex_challenge",
                "title": f"Complex {chapter_name} Challenge",
                "description": f"Solve a complex problem using {chapter_name} with optimal solutions.",
                "focus": "optimal solutions and real-world scenarios"
            }
        ]

        # Select template based on level
        template_index = min((level - 1) // 2, 4)
        template = question_templates[template_index]

        # Generate a unique problem ID
        problem_id = f"{chapter_name.lower().replace(' ', '_')}_level_{level}_{random.randint(1000, 9999)}"

        # Build complete question response
        return {
            "level": level,
            "problem_id": problem_id,
            "title": f"{template['title']} - Level {level}",
            "description": f"{template['description']} This is a level {level}/10 problem focusing on {template['focus']}.",
            "examples": self._generate_examples(chapter_name, level),
            "hints": self._generate_hints(chapter_name, level),
            "function_signature": self._generate_function_signature(language, chapter_name, level),
            "test_cases": self._generate_test_cases(level),
            "solution": self._generate_solution(language, chapter_name, level),
            "solution_explanation": f"This solution demonstrates a level {level} approach to {chapter_name} problems with appropriate complexity considerations. The algorithm efficiently handles the required operations while maintaining good performance characteristics.",
            "time_complexity": self._generate_complexity(level, "time"),
            "space_complexity": self._generate_complexity(level, "space")
        }

    def _get_operation_name(self, chapter_name: str, level: int) -> str:
        """
        Get appropriate operation name based on chapter and level.

        Args:
            chapter_name: Name of the chapter
            level: Difficulty level

        Returns:
            str: Operation name
        """
        # Operation names for different chapters and levels
        operations = {
            "Arrays & Strings": ["Traversal", "Search", "Reverse", "Sort", "Merge", "Rotate", "Partition", "Subarray", "Palindrome", "Compression"],
            "Linked Lists": ["Creation", "Traversal", "Insertion", "Deletion", "Reverse", "Cycle Detection", "Merge", "Sort", "Rotation", "Partition"],
            "Stacks & Queues": ["Push/Pop", "Enqueue/Dequeue", "Min/Max", "Validation", "Reverse", "Sort", "Implementation", "Application", "Optimization", "Advanced"],
            "Trees & BST": ["Traversal", "Search", "Insertion", "Deletion", "Height", "Validation", "Conversion", "Serialization", "Lowest Ancestor", "Path Sum"],
            "Graphs": ["Traversal", "Search", "Path Finding", "Cycle Detection", "Connectivity", "Shortest Path", "Topological Sort", "Minimum Spanning", "Flow", "Advanced"],
            "Dynamic Programming": ["Fibonacci", "Knapsack", "LCS", "LIS", "Coin Change", "Edit Distance", "Matrix Chain", "Partition", "Word Break", "Advanced"],
            "Sorting Algorithms": ["Bubble Sort", "Selection Sort", "Insertion Sort", "Merge Sort", "Quick Sort", "Heap Sort", "Radix Sort", "Bucket Sort", "Tim Sort", "Optimized Sort"],
            "Searching Algorithms": ["Linear Search", "Binary Search", "Jump Search", "Interpolation Search", "Exponential Search", "Ternary Search", "Hash-based Search", "Tree-based Search", "Graph Search", "Advanced Search"],
            "Recursion": ["Basic Recursion", "Factorial", "Fibonacci", "Tower of Hanoi", "Backtracking", "Divide & Conquer", "Memoization", "Dynamic Programming", "Tree Recursion", "Advanced Recursion"],
            "Bit Manipulation": ["Basic Operations", "Set/Clear Bits", "Check Bits", "Count Bits", "Bit Masks", "Bitwise Algorithms", "Bit Tricks", "Advanced Operations", "Optimizations", "Real-world Applications"]
        }

        chapter_ops = operations.get(chapter_name,
                                     ["Operation", "Processing", "Algorithm", "Solution", "Implementation"])
        return chapter_ops[min(level - 1, len(chapter_ops) - 1)]

    def _generate_examples(self, chapter_name: str, level: int) -> List[Dict]:
        """
        Generate example input-output pairs for the question.

        Args:
            chapter_name: Name of the chapter
            level: Difficulty level

        Returns:
            List[Dict]: List of examples
        """
        examples = []

        if level <= 3:
            # Simple examples for beginner levels
            examples.append({
                "input": "[1, 2, 3, 4, 5]",
                "output": "15",
                "explanation": "The sum of all elements in the array is 1 + 2 + 3 + 4 + 5 = 15"
            })
        elif level <= 6:
            # Multiple examples for intermediate levels
            examples.extend([
                {
                    "input": "[1, 2, 3, 4, 5]",
                    "output": "[5, 4, 3, 2, 1]",
                    "explanation": "The array is reversed: first becomes last, last becomes first"
                },
                {
                    "input": "[10, 20, 30]",
                    "output": "[30, 20, 10]",
                    "explanation": "The array is reversed with three elements"
                }
            ])
        else:
            # Complex examples for advanced levels
            examples.extend([
                {
                    "input": "[3, 1, 4, 1, 5, 9, 2, 6]",
                    "output": "[1, 1, 2, 3, 4, 5, 6, 9]",
                    "explanation": "The array is sorted in ascending order using an efficient algorithm"
                },
                {
                    "input": "[9, 8, 7, 6, 5, 4, 3, 2, 1]",
                    "output": "[1, 2, 3, 4, 5, 6, 7, 8, 9]",
                    "explanation": "A reverse-sorted array is properly sorted"
                }
            ])

        return examples

    def _generate_hints(self, chapter_name: str, level: int) -> List[str]:
        """
        Generate helpful hints for the question.

        Args:
            chapter_name: Name of the chapter
            level: Difficulty level

        Returns:
            List[str]: List of hints
        """
        if level <= 3:
            return [
                "Start with the simplest possible approach",
                "Focus on getting the basic functionality working first",
                "Test with the provided examples"
            ]
        elif level <= 6:
            return [
                "Break the problem down into smaller steps",
                "Consider if you can use any built-in functions or methods",
                "Think about edge cases and how to handle them"
            ]
        else:
            return [
                "Consider multiple approaches before implementing",
                "Optimize for both time and space complexity",
                "Test thoroughly with various input sizes and edge cases"
            ]

    def _generate_function_signature(self, language: str, chapter: str, level: int) -> str:
        """
        Generate function signature based on language and level.

        Args:
            language: Programming language
            chapter: Name of the chapter
            level: Difficulty level

        Returns:
            str: Function signature
        """
        if language == "python":
            if level <= 3:
                return "def solution(data):"
            elif level <= 6:
                return "def process_data(data, parameters=None):"
            else:
                return "def advanced_solution(data, constraints):"
        elif language == "java":
            if level <= 3:
                return "public static int solution(int[] data) {"
            elif level <= 6:
                return "public static int[] processData(int[] data, int parameter) {"
            else:
                return "public static int advancedSolution(int[] data, int constraint) {"
        elif language == "javascript":
            if level <= 3:
                return "function solution(data) {"
            elif level <= 6:
                return "function processData(data, parameters) {"
            else:
                return "function advancedSolution(data, constraints) {"
        else:
            if level <= 3:
                return "def solution(data):"
            elif level <= 6:
                return "def process_data(data, parameters=None):"
            else:
                return "def advanced_solution(data, constraints):"

    def _generate_test_cases(self, level: int) -> List[Dict]:
        """
        Generate test cases for the question.

        Args:
            level: Difficulty level

        Returns:
            List[Dict]: List of test cases
        """
        test_cases = []

        # Generate 3-5 test cases based on level
        num_cases = 3 if level <= 5 else 4 if level <= 8 else 5

        for i in range(num_cases):
            if level <= 3:
                test_cases.append({
                    "input": f"[{', '.join(str(j) for j in range(1, i+3))}]",
                    "expected_output": str(sum(range(1, i+3)))
                })
            elif level <= 6:
                arr = list(range(1, i+4))
                expected = list(reversed(arr))
                test_cases.append({
                    "input": str(arr),
                    "expected_output": str(expected)
                })
            else:
                arr = random.sample(range(1, 100), i+3)
                expected = sorted(arr)
                test_cases.append({
                    "input": str(arr),
                    "expected_output": str(expected)
                })

        return test_cases

    def _generate_solution(self, language: str, chapter: str, level: int) -> str:
        """
        Generate solution code based on language and level.

        Args:
            language: Programming language
            chapter: Name of the chapter
            level: Difficulty level

        Returns:
            str: Solution code
        """
        if language == "python":
            if level <= 3:
                return f"""# Level {level} solution for {chapter}
def solution(data):
    \"\"\"
    Basic solution for level {level} {chapter} problem.
    \"\"\"
    # Simple implementation
    return len(data)"""

            elif level <= 6:
                return f"""# Level {level} solution for {chapter}
def process_data(data):
    \"\"\"
    Intermediate solution for level {level} {chapter} problem.
    \"\"\"
    result = []
    for item in data:
        if item > 0:  # Some condition
            result.append(item * 2)  # Some transformation
    return result"""

            else:
                return f"""# Level {level} solution for {chapter}
def advanced_solution(data):
    \"\"\"
    Advanced solution for level {level} {chapter} problem.
    Optimized for performance.
    \"\"\"
    if not data:
        return []
    
    # Use efficient data structures
    from collections import defaultdict
    freq = defaultdict(int)
    
    # Process data
    for item in data:
        freq[item] += 1
    
    # Generate result based on frequency
    result = []
    for item in data:
        if freq[item] > 1:
            result.append(item)
    
    return result"""

        elif language == "java":
            return f"""// Level {level} solution for {chapter}
// Java implementation for {chapter} problem"""

        elif language == "javascript":
            return f"""// Level {level} solution for {chapter}
// JavaScript implementation for {chapter} problem"""

        else:
            return f"# Level {level} solution for {chapter}\n# Implementation in {language}"

    def _generate_complexity(self, level: int, complexity_type: str) -> str:
        """
        Generate time/space complexity analysis.

        Args:
            level: Difficulty level
            complexity_type: "time" or "space"

        Returns:
            str: Complexity notation
        """
        if level <= 3:
            return "O(n)" if complexity_type == "time" else "O(1)"
        elif level <= 6:
            return "O(n log n)" if complexity_type == "time" else "O(n)"
        else:
            return "O(n¬≤)" if complexity_type == "time" else "O(n)"

    def analyze_user_code(self, user_code: str, question_data: Dict,
                         language: str) -> Dict[str, Any]:
        """
        Analyze user's submitted code (simulated - would integrate with actual code analysis).

        Args:
            user_code: Code submitted by user
            question_data: Original question data
            language: Programming language

        Returns:
            Dict: Analysis results with scores and feedback
        """
        # Simulate code analysis
        is_correct = random.choice([True, False, True])  # 2/3 chance of being correct

        if is_correct:
            correctness_score = random.randint(85, 100)
            feedback = "Good job! Your solution appears to be correct and efficient."
            strengths = ["Correct logic implementation", "Good variable naming", "Proper error handling"]
            improvements = ["Could add more comments", "Consider edge cases more thoroughly"]
        else:
            correctness_score = random.randint(50, 84)
            feedback = "Your solution has some issues. Review the logic and test with different inputs."
            strengths = ["Good code structure", "Clear function organization"]
            improvements = ["Fix logic error in main algorithm", "Handle edge cases", "Improve time complexity"]

        passed_cases = random.randint(1, 3)
        total_cases = 3

        return {
            "correctness_score": correctness_score,
            "is_correct": is_correct,
            "feedback": feedback,
            "strengths": strengths,
            "improvements": improvements,
            "efficiency_analysis": f"Time complexity appears to be {question_data.get('time_complexity', 'O(n)')}. Space complexity is {question_data.get('space_complexity', 'O(1)')}.",
            "bugs": [] if is_correct else ["Logic error in main loop", "Incorrect boundary condition"],
            "passed_test_cases": passed_cases,
            "total_test_cases": total_cases,
            "hints": ["Review the problem requirements", "Test with different inputs", "Consider time complexity"] if not is_correct else [],
            "analyzed_at": time.time()
        }


class DynamicChapterManager:
    """
    Manages DSA chapters dynamically generated by OpenAI.
    Provides access to chapter data and metadata with caching.
    """

    def __init__(self, openai_service: OpenAIService):
        """Initialize with OpenAI service."""
        self.openai_service = openai_service
        self.chapters_cache = {}  # Cache chapters by language

    def get_chapters(self, language: str = "python") -> List[Dict[str, Any]]:
        """
        Get chapters for a specific language.

        Args:
            language: Programming language

        Returns:
            List[Dict]: List of chapter objects
        """
        # Check cache first
        if language in self.chapters_cache:
            print(f"üì¶ Serving chapters for {language} from cache")
            return self.chapters_cache[language]

        # Generate dynamic chapters
        print(f"üöÄ Generating dynamic chapters for {language}...")
        chapters = self.openai_service.generate_chapters(language)

        # Cache the chapters
        self.chapters_cache[language] = chapters

        return chapters

    def get_chapter(self, chapter_id: int, language: str = "python") -> Optional[Dict[str, Any]]:
        """
        Get a specific chapter by ID and language.

        Args:
            chapter_id: Chapter ID
            language: Programming language

        Returns:
            Dict: Chapter data or None if not found
        """
        chapters = self.get_chapters(language)
        return next((ch for ch in chapters if ch["id"] == chapter_id), None)

    def clear_cache(self) -> None:
        """Clear the chapters cache."""
        self.chapters_cache.clear()
        print("‚úÖ Chapters cache cleared")


class ContentCache:
    """
    Simple in-memory cache for storing generated content.
    Reduces API calls and improves response times.
    """

    def __init__(self):
        """Initialize empty cache."""
        self.cache = {}

    def get(self, key: str) -> Optional[Any]:
        """
        Get value from cache by key.

        Args:
            key: Cache key

        Returns:
            Any: Cached value or None
        """
        return self.cache.get(key)

    def set(self, key: str, value: Any) -> bool:
        """
        Set value in cache.

        Args:
            key: Cache key
            value: Value to cache

        Returns:
            bool: True if successful
        """
        self.cache[key] = value
        return True

    def get_concept(self, chapter_id: int, language: str) -> Optional[Dict]:
        """
        Get cached concept content.

        Args:
            chapter_id: Chapter ID
            language: Programming language

        Returns:
            Dict: Cached concept or None
        """
        concept_key = f"concept_{chapter_id}_{language}"
        return self.get(concept_key)

    def set_concept(self, chapter_id: int, language: str, concept: Dict) -> bool:
        """
        Cache concept content.

        Args:
            chapter_id: Chapter ID
            language: Programming language
            concept: Concept data to cache

        Returns:
            bool: True if successful
        """
        concept_key = f"concept_{chapter_id}_{language}"
        return self.set(concept_key, concept)

    def get_question(self, chapter_id: int, language: str, level: int) -> Optional[Dict]:
        """
        Get cached question.

        Args:
            chapter_id: Chapter ID
            language: Programming language
            level: Difficulty level

        Returns:
            Dict: Cached question or None
        """
        question_key = f"question_{chapter_id}_{language}_{level}"
        return self.get(question_key)

    def set_question(self, chapter_id: int, language: str, level: int, question: Dict) -> bool:
        """
        Cache question.

        Args:
            chapter_id: Chapter ID
            language: Programming language
            level: Difficulty level
            question: Question data to cache

        Returns:
            bool: True if successful
        """
        question_key = f"question_{chapter_id}_{language}_{level}"
        return self.set(question_key, question)

    def get_solution(self, chapter_id: int, language: str, level: int) -> Optional[str]:
        """
        Get solution from cached question.

        Args:
            chapter_id: Chapter ID
            language: Programming language
            level: Difficulty level

        Returns:
            str: Solution code or None
        """
        question = self.get_question(chapter_id, language, level)
        return question.get('solution') if question else None

    def clear(self) -> None:
        """
        Clear all cached content.
        """
        self.cache.clear()
        print("‚úÖ Content cache cleared")


# ============================================================================
# SERVICE INITIALIZATION
# ============================================================================

# Initialize service instances
print("üöÄ Initializing DSA Learning Platform API...")
openai_service = OpenAIService()
chapter_manager = DynamicChapterManager(openai_service)
cache = ContentCache()


# ============================================================================
# API ENDPOINTS
# ============================================================================

@app.route('/api/health', methods=['GET'])
def health_check():
    """
    Health check endpoint.
    Returns the status of the API and its dependencies.

    Returns:
        JSON: Health status information
    """
    chapters_count = len(chapter_manager.get_chapters(Config.DEFAULT_LANGUAGE))

    return jsonify({
        'status': 'healthy',
        'openai_connected': openai_service.check_connection(),
        'supported_languages': Config.SUPPORTED_LANGUAGES,
        'default_chapters_count': chapters_count,
        'cache_size': len(cache.cache),
        'chapters_cache_size': len(chapter_manager.chapters_cache),
        'version': '1.0.0',
        'dynamic_chapters': True
    })


@app.route('/api/languages', methods=['GET'])
def get_languages():
    """
    Get supported programming languages.

    Returns:
        JSON: List of supported languages
    """
    return jsonify({
        'languages': Config.SUPPORTED_LANGUAGES,
        'default': Config.DEFAULT_LANGUAGE,
        'count': len(Config.SUPPORTED_LANGUAGES),
        'dynamic_chapters': True
    })


@app.route('/api/chapters', methods=['GET'])
def get_chapters_endpoint():
    """
    Get dynamic DSA chapters generated by OpenAI.

    Query Parameters:
        language: Programming language (default: 'python')
        force_refresh: Force refresh chapters from OpenAI (default: false)

    Returns:
        JSON: List of dynamic chapters with metadata
    """
    language = request.args.get('language', Config.DEFAULT_LANGUAGE)
    force_refresh = request.args.get('force_refresh', 'false').lower() == 'true'

    # Validate language
    if language not in Config.SUPPORTED_LANGUAGES:
        return jsonify({'error': f'Unsupported language: {language}'}), 400

    # Force refresh if requested
    if force_refresh and language in chapter_manager.chapters_cache:
        del chapter_manager.chapters_cache[language]
        print(f"üîÑ Force refreshing chapters for {language}")

    # Get dynamic chapters
    chapters = chapter_manager.get_chapters(language)

    return jsonify({
        'chapters': chapters,
        'language': language,
        'total_chapters': len(chapters),
        'min_level': Config.MIN_QUESTION_LEVEL,
        'max_level': Config.MAX_QUESTION_LEVEL,
        'dynamic': True,
        'cached': language in chapter_manager.chapters_cache and not force_refresh
    })


@app.route('/api/chapters/<int:chapter_id>/concept', methods=['GET'])
def get_concept(chapter_id: int):
    """
    Get concept content for a specific chapter.

    Args:
        chapter_id: ID of the chapter

    Query Parameters:
        language: Programming language (default: 'python')

    Returns:
        JSON: Concept content including theory, examples, and objectives
    """
    language = request.args.get('language', Config.DEFAULT_LANGUAGE)

    # Validate language
    if language not in Config.SUPPORTED_LANGUAGES:
        return jsonify({'error': f'Unsupported language: {language}'}), 400

    # Try to get from cache first
    concept = cache.get_concept(chapter_id, language)

    if concept:
        print(f"üì¶ Serving concept for chapter {chapter_id} in {language} from cache")
        return jsonify({
            'concept': concept,
            'language': language,
            'chapter_id': chapter_id,
            'cached': True,
            'dynamic_chapter': True
        })

    # If not in cache, check if chapter exists
    chapter = chapter_manager.get_chapter(chapter_id, language)
    if not chapter:
        return jsonify({'error': f'Chapter not found: {chapter_id} for language {language}'}), 404

    print(f"üöÄ Generating concept content for {chapter['name']} in {language}...")

    # Generate concept content
    concept = openai_service.generate_concept_content(
        chapter["name"],
        chapter["topics"],
        language
    )

    # Cache the concept for future requests
    cache.set_concept(chapter_id, language, concept)

    return jsonify({
        'concept': concept,
        'language': language,
        'chapter_id': chapter_id,
        'cached': False,
        'dynamic_chapter': True
    })


@app.route('/api/chapters/<int:chapter_id>/questions/<int:level>', methods=['GET'])
def get_question(chapter_id: int, level: int):
    """
    Get a coding question for a specific chapter and difficulty level.

    Args:
        chapter_id: ID of the chapter
        level: Difficulty level (1-10)

    Query Parameters:
        language: Programming language (default: 'python')

    Returns:
        JSON: Complete question data
    """
    language = request.args.get('language', Config.DEFAULT_LANGUAGE)

    # Validate language
    if language not in Config.SUPPORTED_LANGUAGES:
        return jsonify({'error': f'Unsupported language: {language}'}), 400

    # Validate level range
    if level < Config.MIN_QUESTION_LEVEL or level > Config.MAX_QUESTION_LEVEL:
        return jsonify({
            'error': f'Level must be between {Config.MIN_QUESTION_LEVEL} and {Config.MAX_QUESTION_LEVEL}',
            'min_level': Config.MIN_QUESTION_LEVEL,
            'max_level': Config.MAX_QUESTION_LEVEL
        }), 400

    # Try to get from cache first
    question = cache.get_question(chapter_id, language, level)

    if question:
        print(f"üì¶ Serving question for chapter {chapter_id}, level {level} in {language} from cache")
        return jsonify({
            'question': question,
            'level': level,
            'language': language,
            'chapter_id': chapter_id,
            'cached': True,
            'dynamic_chapter': True
        })

    # If not in cache, check if chapter exists
    chapter = chapter_manager.get_chapter(chapter_id, language)
    if not chapter:
        return jsonify({'error': f'Chapter not found: {chapter_id} for language {language}'}), 404

    print(f"üöÄ Generating question for {chapter['name']} - Level {level} in {language}...")

    # Generate single question
    question = openai_service.generate_single_question(
        chapter["name"],
        chapter["topics"],
        language,
        level
    )

    # Cache the question for future requests
    cache.set_question(chapter_id, language, level, question)

    return jsonify({
        'question': question,
        'level': level,
        'language': language,
        'chapter_id': chapter_id,
        'cached': False,
        'dynamic_chapter': True
    })


@app.route('/api/chapters/<int:chapter_id>/questions/<int:level>/solution', methods=['GET'])
def get_solution(chapter_id: int, level: int):
    """
    Get the solution for a specific question.

    Args:
        chapter_id: ID of the chapter
        level: Difficulty level

    Query Parameters:
        language: Programming language (default: 'python')

    Returns:
        JSON: Solution code and explanation
    """
    language = request.args.get('language', Config.DEFAULT_LANGUAGE)

    # Validate language
    if language not in Config.SUPPORTED_LANGUAGES:
        return jsonify({'error': f'Unsupported language: {language}'}), 400

    # Validate level range
    if level < Config.MIN_QUESTION_LEVEL or level > Config.MAX_QUESTION_LEVEL:
        return jsonify({
            'error': f'Level must be between {Config.MIN_QUESTION_LEVEL} and {Config.MAX_QUESTION_LEVEL}'
        }), 400

    # Get solution from cache
    solution = cache.get_solution(chapter_id, language, level)
    if not solution:
        return jsonify({'error': 'Solution not found. Please generate the question first.'}), 404

    return jsonify({
        'solution': solution,
        'level': level,
        'language': language,
        'chapter_id': chapter_id,
        'dynamic_chapter': True
    })


@app.route('/api/chapters/<int:chapter_id>/validate', methods=['POST'])
def validate_code(chapter_id: int):
    """
    Validate user's code submission.

    Args:
        chapter_id: ID of the chapter

    Request Body (JSON):
        code: User's code submission (required)
        language: Programming language (default: 'python')
        level: Difficulty level (default: 1)

    Returns:
        JSON: Code analysis with feedback and score
    """
    data = request.get_json()

    # Validate request data
    if not data:
        return jsonify({'error': 'Request body is required'}), 400

    if 'code' not in data:
        return jsonify({'error': 'Code is required'}), 400

    language = data.get('language', Config.DEFAULT_LANGUAGE)
    user_code = data['code']
    level = data.get('level', 1)

    # Validate language
    if language not in Config.SUPPORTED_LANGUAGES:
        return jsonify({'error': f'Unsupported language: {language}'}), 400

    # Validate level range
    if level < Config.MIN_QUESTION_LEVEL or level > Config.MAX_QUESTION_LEVEL:
        return jsonify({
            'error': f'Level must be between {Config.MIN_QUESTION_LEVEL} and {Config.MAX_QUESTION_LEVEL}'
        }), 400

    # Get the question data for analysis
    question = cache.get_question(chapter_id, language, level)
    if not question:
        return jsonify({'error': 'Question data not found. Please generate the question first.'}), 404

    print(f"üîç Analyzing code for chapter {chapter_id}, level {level} in {language}...")

    # Analyze the user's code
    analysis = openai_service.analyze_user_code(user_code, question, language)

    return jsonify({
        'analysis': analysis,
        'level': level,
        'language': language,
        'chapter_id': chapter_id,
        'timestamp': time.time(),
        'dynamic_chapter': True
    })


@app.route('/api/preload', methods=['POST'])
def preload_content():
    """
    Preload concepts and questions into cache.
    Useful for warming up the cache before user requests.

    Request Body (JSON, optional):
        languages: List of languages to preload (default: ['python'])
        levels: List of levels to preload (default: [1, 5, 10])
        chapters: List of chapter IDs to preload (default: first 3 chapters)

    Returns:
        JSON: Preload results with status for each item
    """
    data = request.get_json() or {}

    languages = data.get('languages', ['python'])
    levels = data.get('levels', [1, 5, 10])

    results = []
    start_time = time.time()

    print(f"üî• Starting preload for {len(languages)} languages, {len(levels)} levels")

    # Preload content for all specified languages
    for language in languages:
        if language not in Config.SUPPORTED_LANGUAGES:
            print(f"‚ö†Ô∏è Skipping unsupported language: {language}")
            continue

        # Get dynamic chapters for this language
        chapters = chapter_manager.get_chapters(language)

        # Determine which chapters to preload
        chapter_ids = data.get('chapters')
        if chapter_ids:
            chapters_to_preload = [ch for ch in chapters if ch['id'] in chapter_ids]
        else:
            # Default: preload first 3 chapters
            chapters_to_preload = chapters[:3]

        print(f"   Preloading {len(chapters_to_preload)} chapters for {language}...")

        for chapter in chapters_to_preload:
            # Preload concept
            concept_key = f"concept_{chapter['id']}_{language}"
            if not cache.get(concept_key):
                print(f"     Preloading concept for {chapter['name']}...")
                try:
                    concept = openai_service.generate_concept_content(
                        chapter["name"],
                        chapter["topics"],
                        language
                    )
                    cache.set_concept(chapter['id'], language, concept)
                    results.append({
                        'type': 'concept',
                        'chapter_id': chapter['id'],
                        'chapter_name': chapter['name'],
                        'language': language,
                        'status': 'loaded'
                    })
                except Exception as e:
                    print(f"     ‚ùå Error preloading concept: {e}")
                    results.append({
                        'type': 'concept',
                        'chapter_id': chapter['id'],
                        'chapter_name': chapter['name'],
                        'language': language,
                        'status': 'error',
                        'error': str(e)
                    })

            # Preload questions for each level
            for level in levels:
                if level < Config.MIN_QUESTION_LEVEL or level > Config.MAX_QUESTION_LEVEL:
                    print(f"     ‚ö†Ô∏è Skipping invalid level: {level}")
                    continue

                question_key = f"question_{chapter['id']}_{language}_{level}"
                if not cache.get(question_key):
                    print(f"     Preloading {chapter['name']} - Level {level}...")
                    try:
                        question = openai_service.generate_single_question(
                            chapter["name"],
                            chapter["topics"],
                            language,
                            level
                        )
                        cache.set_question(chapter['id'], language, level, question)
                        results.append({
                            'type': 'question',
                            'chapter_id': chapter['id'],
                            'chapter_name': chapter['name'],
                            'language': language,
                            'level': level,
                            'status': 'loaded'
                        })
                        # Small delay to avoid rate limiting
                        time.sleep(0.5)
                    except Exception as e:
                        print(f"     ‚ùå Error preloading question: {e}")
                        results.append({
                            'type': 'question',
                            'chapter_id': chapter['id'],
                            'chapter_name': chapter['name'],
                            'language': language,
                            'level': level,
                            'status': 'error',
                            'error': str(e)
                        })

    elapsed_time = time.time() - start_time

    return jsonify({
        'message': f'Preloaded {len(results)} items in {elapsed_time:.2f} seconds',
        'results': results,
        'summary': {
            'total_items': len(results),
            'successful': len([r for r in results if r['status'] == 'loaded']),
            'errors': len([r for r in results if r['status'] == 'error']),
            'time_seconds': elapsed_time,
            'dynamic_chapters': True
        }
    })


@app.route('/api/debug/cache', methods=['GET'])
def debug_cache():
    """
    Debug endpoint to check cache status.
    Useful for monitoring and troubleshooting.

    Returns:
        JSON: Cache statistics and OpenAI connection status
    """
    cache_keys = list(cache.cache.keys())
    concept_keys = [k for k in cache_keys if k.startswith('concept_')]
    question_keys = [k for k in cache_keys if k.startswith('question_')]

    # Count by language
    language_counts = {}
    for key in cache_keys:
        parts = key.split('_')
        if len(parts) >= 3:
            lang = parts[-1]  # Last part is language
            language_counts[lang] = language_counts.get(lang, 0) + 1

    status = {
        'concepts': len(concept_keys),
        'questions': len(question_keys),
        'total_content_cache': len(cache_keys),
        'chapters_cache_size': len(chapter_manager.chapters_cache),
        'by_language': language_counts,
        'openai_connected': openai_service.check_connection(),
        'dynamic_chapters': True
    }

    return jsonify(status)


@app.route('/api/debug/cache/clear', methods=['POST'])
def clear_cache():
    """
    Clear all cached content.

    Returns:
        JSON: Confirmation message
    """
    cache.clear()
    chapter_manager.clear_cache()
    return jsonify({
        'message': 'All caches cleared successfully',
        'timestamp': time.time(),
        'dynamic_chapters': True
    })


@app.route('/api/debug/chapters/refresh', methods=['POST'])
def refresh_chapters():
    """
    Refresh dynamic chapters from OpenAI.

    Request Body (JSON, optional):
        languages: List of languages to refresh (default: ['python'])

    Returns:
        JSON: Refresh results
    """
    data = request.get_json() or {}
    languages = data.get('languages', ['python'])

    results = []

    for language in languages:
        if language not in Config.SUPPORTED_LANGUAGES:
            results.append({
                'language': language,
                'status': 'error',
                'message': f'Unsupported language: {language}'
            })
            continue

        # Remove from cache to force refresh
        if language in chapter_manager.chapters_cache:
            del chapter_manager.chapters_cache[language]

        # Generate new chapters
        try:
            chapters = chapter_manager.get_chapters(language)
            results.append({
                'language': language,
                'status': 'success',
                'message': f'Refreshed {len(chapters)} chapters',
                'chapters_count': len(chapters)
            })
        except Exception as e:
            results.append({
                'language': language,
                'status': 'error',
                'message': str(e)
            })

    return jsonify({
        'results': results,
        'timestamp': time.time(),
        'dynamic_chapters': True
    })


# ============================================================================
# ERROR HANDLERS
# ============================================================================

@app.errorhandler(404)
def not_found(error):
    """
    Handle 404 errors.

    Args:
        error: Error object

    Returns:
        JSON: Error message
    """
    return jsonify({
        'error': 'Endpoint not found',
        'message': str(error),
        'dynamic_chapters': True
    }), 404


@app.errorhandler(500)
def internal_error(error):
    """
    Handle 500 errors.

    Args:
        error: Error object

    Returns:
        JSON: Error message
    """
    return jsonify({
        'error': 'Internal server error',
        'message': str(error),
        'dynamic_chapters': True
    }), 500


# ============================================================================
# APPLICATION STARTUP
# ============================================================================

if __name__ == '__main__':
    """Main entry point for the Flask application."""

    # Print startup information
    print("\n" + "="*60)
    print("üöÄ DSA Learning Platform API Starting...")
    print("="*60)
    print(f"üåê Supported Languages: {', '.join(Config.SUPPORTED_LANGUAGES)}")
    print(f"üéØ Difficulty Levels: {Config.MIN_QUESTION_LEVEL} to {Config.MAX_QUESTION_LEVEL}")
    print(f"üîå OpenAI Status: {'‚úÖ Connected' if openai_service.connected else '‚ö†Ô∏è Using Fallback Mode'}")
    print(f"üìö Chapters: Dynamic (generated by OpenAI)")
    print(f"üíæ Cache: Ready")

    print("\nüìã API Endpoints:")
    print("   GET  /api/health                         - Health check")
    print("   GET  /api/languages                     - Get supported languages")
    print("   GET  /api/chapters?language=python      - Get dynamic chapters")
    print("   GET  /api/chapters?language=python&force_refresh=true")
    print("                                         - Force refresh dynamic chapters")
    print("   GET  /api/chapters/1/concept?language=python")
    print("                                         - Get concept for chapter 1")
    print("   GET  /api/chapters/1/questions/5?language=python")
    print("                                         - Get level 5 question for chapter 1")
    print("   POST /api/chapters/1/validate           - Validate user code")
    print("   POST /api/preload                      - Preload content into cache")
    print("   GET  /api/debug/cache                  - Check cache status")
    print("   POST /api/debug/cache/clear            - Clear all caches")
    print("   POST /api/debug/chapters/refresh       - Refresh dynamic chapters")

    print("\n‚ö° Ready to serve dynamic DSA learning content!")
    print("="*60 + "\n")

    # Start the Flask development server
    app.run(debug=True, host='0.0.0.0', port=5000)